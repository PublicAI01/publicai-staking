use anyhow::Result;
use near_sdk::json_types::U128;
use near_workspaces::operations::Function;
use near_workspaces::types::Gas;
use near_workspaces::{sandbox, types::NearToken, Account, Contract};
use serde_json::json;
use std::fs;
use std::path::Path;

/// Integration test that deploys the real staking & token contracts and shows that
/// unstake() creates a failing cross-contract call (ft_transfer on the user account).
#[tokio::test]
async fn test_unstake_assets_drain() -> Result<()> {
    // 1. Spin up a local sandbox network
    let worker = sandbox().await?;

    // 2. Load the token and staking contracts from WASM files
    let token_wasm = fs::read(Path::new(
        "../publicai-token/target/near/publicai_token.wasm",
    ))?;
    let staking_wasm = fs::read(Path::new("./target/near/publicai_staking.wasm"))?;

    // 3. Deploy the token contract
    let token_contract: Contract = worker.dev_deploy(&token_wasm).await?;

    // Initialize token contract
    let root_account = worker.root_account()?;
    let metadata = json!({
        "spec": "ft-1.0.0",
        "name": "Test Token",
        "symbol": "TT",
        "decimals": 18,
        "icon": null,
        "reference": null,
        "reference_hash": null
    });

    let _ = root_account
        .call(token_contract.id(), "new")
        .args_json(json!({
            "owner_id": root_account.id(),
            "total_supply": U128(1_000_000_000u128),
            "metadata": metadata
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?; // Unwrap to catch init failure

    // 4. Deploy the staking contract
    let staking_contract: Contract = worker.dev_deploy(&staking_wasm).await?;

    let _ = root_account
        .call(staking_contract.id(), "new")
        .args_json((root_account.id(), token_contract.id(), U128(1u128)))
        .transact()
        .await?
        .into_result()?; // Unwrap to catch init failure

    // 5. Create two user accounts and mint them some tokens
    let alice: Account = worker.dev_create_account().await?;
    let bob: Account = worker.dev_create_account().await?;

    // Register alice for storage
    let _ = root_account
        .call(token_contract.id(), "storage_deposit")
        .args_json(json!({ "account_id": alice.id(), "registration_only": null }))
        .deposit(NearToken::from_yoctonear(
            1_250_000_000_000_000_000_000_000u128,
        ))
        .transact()
        .await?
        .into_result()?; // Unwrap to catch failure

    // Register bob for storage
    let _ = root_account
        .call(token_contract.id(), "storage_deposit")
        .args_json(json!({ "account_id": bob.id(), "registration_only": null }))
        .deposit(NearToken::from_yoctonear(
            1_250_000_000_000_000_000_000_000u128,
        ))
        .transact()
        .await?
        .into_result()?; // Unwrap to catch failure

    // Register staking_contract for storage (must be before ft_transfer_call)
    let _ = root_account
        .call(token_contract.id(), "storage_deposit")
        .args_json(json!({ "account_id": staking_contract.id(), "registration_only": null }))
        .deposit(NearToken::from_yoctonear(
            1_250_000_000_000_000_000_000_000u128,
        ))
        .transact()
        .await?
        .into_result()?; // Unwrap to catch failure

    // Transfer tokens to alice
    let _ = root_account
        .call(token_contract.id(), "ft_transfer")
        .args_json(json!({
            "receiver_id": alice.id(),
            "amount": U128(1_000_000u128),
            "memo": null
        }))
        .deposit(NearToken::from_yoctonear(1))
        .max_gas()
        .transact()
        .await?
        .into_result()?; // Unwrap to catch failure

    // 6. Alice stakes her tokens via ft_transfer_call
    let exec = alice
        .call(token_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": staking_contract.id(),
            "amount": U128(1_000_000u128),
            "memo": null,
            "msg": ""
        }))
        .deposit(NearToken::from_yoctonear(1))
        .max_gas()
        .transact()
        .await?;

    println!(
        "Alice's ft_transfer_call is_success: {:?}",
        exec.is_success()
    );
    exec.clone().into_result()?; // Unwrap to catch failure

    // Wait for cross-contract calls to complete by advancing the sandbox
    // NEAR cross-contract calls are asynchronous and take multiple blocks
    worker.fast_forward(10).await?;

    // Transfer tokens to bob
    let _ = root_account
        .call(token_contract.id(), "ft_transfer")
        .args_json(json!({
            "receiver_id": bob.id(),
            "amount": U128(1_000_000u128),
            "memo": null
        }))
        .deposit(NearToken::from_yoctonear(1))
        .max_gas()
        .transact()
        .await?
        .into_result()?; // Unwrap to catch failure

    // Bob stakes his tokens
    let exec = bob
        .call(token_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": staking_contract.id(),
            "amount": U128(1_000_000u128),
            "memo": null,
            "msg": ""
        }))
        .deposit(NearToken::from_yoctonear(1))
        .max_gas()
        .transact()
        .await?;

    println!("Bob's ft_transfer_call is_success: {:?}", exec.is_success());
    exec.clone().into_result()?; // Unwrap to catch failure

    worker.fast_forward(10).await?;

    // Check Alice's balance after ft_transfer_call and cross-contract completion
    let alice_balance_after: U128 = alice
        .view(token_contract.id(), "ft_balance_of")
        .args_json(json!({ "account_id": alice.id() }))
        .await?
        .json()?;
    println!(
        "Alice's balance after ft_transfer_call: {}",
        alice_balance_after.0
    );

    let bob_balance_after: U128 = bob
        .view(token_contract.id(), "ft_balance_of")
        .args_json(json!({ "account_id": bob.id() }))
        .await?
        .json()?;
    println!(
        "Bob's balance after ft_transfer_call: {}",
        bob_balance_after.0
    );

    // Check staking contract balance after ft_transfer_call and cross-contract completion
    let staking_balance_after: U128 = alice
        .view(token_contract.id(), "ft_balance_of")
        .args_json(json!({ "account_id": staking_contract.id() }))
        .await?
        .json()?;
    println!(
        "Staking contract balance after ft_transfer_call: {}",
        staking_balance_after.0
    );

    // 6b. Confirm stake exists
    let stake_info: serde_json::Value = alice
        .view(staking_contract.id(), "get_stake_info")
        .args_json(json!({ "account_id": alice.id() }))
        .await?
        .json()?;
    println!(
        "Alice's stake info after cross-contract completion: {:?}",
        stake_info
    );
    assert!(stake_info != serde_json::Value::Null, "Stake not created");

    let stake_info_bob: serde_json::Value = bob
        .view(staking_contract.id(), "get_stake_info")
        .args_json(json!({ "account_id": bob.id() }))
        .await?
        .json()?;
    println!(
        "Bob's stake info after cross-contract completion: {:?}",
        stake_info_bob
    );
    assert!(
        stake_info_bob != serde_json::Value::Null,
        "Stake not created"
    );

    // Alice initiates a batched transaction with two unstake calls
    let unstake_batch_tx = alice
        .batch(staking_contract.id())
        .call(
            Function::new("unstake")
                .deposit(NearToken::from_yoctonear(1))
                .gas(Gas::from_tgas(150)),
        )
        .call(
            Function::new("unstake")
                .deposit(NearToken::from_yoctonear(1))
                .gas(Gas::from_tgas(150)),
        )
        .transact()
        .await?;
    assert_eq!(
        unstake_batch_tx.is_success(),
        false,
        "Batched unstake transaction should failed"
    );
    // println!("Batched unstake transaction success: {:?}", unstake_batch_tx.is_success());

    // Wait for the unstake cross-contract call to complete
    worker.fast_forward(10).await?;

    // Verify that the tokens are still held by the staking contract
    let alice_balance: U128 = alice
        .view(token_contract.id(), "ft_balance_of")
        .args_json(json!({ "account_id": alice.id() }))
        .await?
        .json()?;
    assert_eq!(
        alice_balance.0, 0,
        "Alice balance should be 0 after failed unstake"
    );
    println!("Alice's balance after unstake: {}", alice_balance.0);

    let unstake_tx = alice
        .batch(staking_contract.id())
        .call(
            Function::new("unstake")
                .deposit(NearToken::from_yoctonear(1))
                .gas(Gas::from_tgas(150)),
        )
        .transact()
        .await?;
    assert_eq!(
        unstake_tx.is_success(),
        true,
        "Unstake transaction should success"
    );
    // Wait for the unstake cross-contract call to complete
    worker.fast_forward(10).await?;

    let alice_stake_info: serde_json::Value = alice
        .view(staking_contract.id(), "get_stake_info")
        .args_json(json!({ "account_id": alice.id() }))
        .await?
        .json()?;
    println!(
        "Alice's stake info after cross-contract completion: {:?}",
        stake_info
    );
    assert_eq!(alice_stake_info, serde_json::Value::Null, "Already unstake");
    let total_staked: serde_json::Value = alice
        .view(staking_contract.id(), "get_total_stake")
        .await?
        .json()?;
    assert_eq!(total_staked.as_u64().unwrap(), 1000000, "Already unstake");
    Ok(())
}
